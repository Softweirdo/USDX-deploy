import{bF as v,bG as F,bD as P,by as b}from"./index-CzTMIYai.js";class j extends Map{constructor(e){super(),Object.defineProperty(this,"maxSize",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.maxSize=e}get(e){const s=super.get(e);return super.has(e)&&s!==void 0&&(this.delete(e),super.set(e,s)),s}set(e,s){if(super.set(e,s),this.maxSize&&this.size>this.maxSize){const n=this.keys().next().value;n&&this.delete(n)}return this}}const C={checksum:new j(8192)},p=C.checksum;function x(t){if(!Number.isSafeInteger(t)||t<0)throw new Error("positive integer expected, got "+t)}function M(t){return t instanceof Uint8Array||ArrayBuffer.isView(t)&&t.constructor.name==="Uint8Array"}function y(t,...e){if(!M(t))throw new Error("Uint8Array expected");if(e.length>0&&!e.includes(t.length))throw new Error("Uint8Array expected of length "+e+", got length="+t.length)}function g(t,e=!0){if(t.destroyed)throw new Error("Hash instance has been destroyed");if(e&&t.finished)throw new Error("Hash#digest() has already been called")}function z(t,e){y(t);const s=e.outputLen;if(t.length<s)throw new Error("digestInto() expects output buffer of length at least "+s)}/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */const N=t=>new Uint32Array(t.buffer,t.byteOffset,Math.floor(t.byteLength/4)),m=new Uint8Array(new Uint32Array([287454020]).buffer)[0]===68,X=t=>t<<24&4278190080|t<<8&16711680|t>>>8&65280|t>>>24&255;function A(t){for(let e=0;e<t.length;e++)t[e]=X(t[e])}function $(t){if(typeof t!="string")throw new Error("utf8ToBytes expected string, got "+typeof t);return new Uint8Array(new TextEncoder().encode(t))}function O(t){return typeof t=="string"&&(t=$(t)),y(t),t}class R{clone(){return this._cloneInto()}}function K(t){const e=n=>t().update(O(n)).digest(),s=t();return e.outputLen=s.outputLen,e.blockLen=s.blockLen,e.create=()=>t(),e}const d=BigInt(2**32-1),k=BigInt(32);function D(t,e=!1){return e?{h:Number(t&d),l:Number(t>>k&d)}:{h:Number(t>>k&d)|0,l:Number(t&d)|0}}function G(t,e=!1){let s=new Uint32Array(t.length),n=new Uint32Array(t.length);for(let o=0;o<t.length;o++){const{h:i,l:r}=D(t[o],e);[s[o],n[o]]=[i,r]}return[s,n]}const V=(t,e,s)=>t<<s|e>>>32-s,q=(t,e,s)=>e<<s|t>>>32-s,J=(t,e,s)=>e<<s-32|t>>>64-s,Q=(t,e,s)=>t<<s-32|e>>>64-s,E=[],_=[],S=[],W=BigInt(0),f=BigInt(1),Y=BigInt(2),Z=BigInt(7),tt=BigInt(256),et=BigInt(113);for(let t=0,e=f,s=1,n=0;t<24;t++){[s,n]=[n,(2*s+3*n)%5],E.push(2*(5*n+s)),_.push((t+1)*(t+2)/2%64);let o=W;for(let i=0;i<7;i++)e=(e<<f^(e>>Z)*et)%tt,e&Y&&(o^=f<<(f<<BigInt(i))-f);S.push(o)}const[st,nt]=G(S,!0),I=(t,e,s)=>s>32?J(t,e,s):V(t,e,s),L=(t,e,s)=>s>32?Q(t,e,s):q(t,e,s);function rt(t,e=24){const s=new Uint32Array(10);for(let n=24-e;n<24;n++){for(let r=0;r<10;r++)s[r]=t[r]^t[r+10]^t[r+20]^t[r+30]^t[r+40];for(let r=0;r<10;r+=2){const c=(r+8)%10,h=(r+2)%10,a=s[h],u=s[h+1],H=I(a,u,1)^s[c],T=L(a,u,1)^s[c+1];for(let l=0;l<50;l+=10)t[r+l]^=H,t[r+l+1]^=T}let o=t[2],i=t[3];for(let r=0;r<24;r++){const c=_[r],h=I(o,i,c),a=L(o,i,c),u=E[r];o=t[u],i=t[u+1],t[u]=h,t[u+1]=a}for(let r=0;r<50;r+=10){for(let c=0;c<10;c++)s[c]=t[r+c];for(let c=0;c<10;c++)t[r+c]^=~s[(c+2)%10]&s[(c+4)%10]}t[0]^=st[n],t[1]^=nt[n]}s.fill(0)}class w extends R{constructor(e,s,n,o=!1,i=24){if(super(),this.blockLen=e,this.suffix=s,this.outputLen=n,this.enableXOF=o,this.rounds=i,this.pos=0,this.posOut=0,this.finished=!1,this.destroyed=!1,x(n),0>=this.blockLen||this.blockLen>=200)throw new Error("Sha3 supports only keccak-f1600 function");this.state=new Uint8Array(200),this.state32=N(this.state)}keccak(){m||A(this.state32),rt(this.state32,this.rounds),m||A(this.state32),this.posOut=0,this.pos=0}update(e){g(this);const{blockLen:s,state:n}=this;e=O(e);const o=e.length;for(let i=0;i<o;){const r=Math.min(s-this.pos,o-i);for(let c=0;c<r;c++)n[this.pos++]^=e[i++];this.pos===s&&this.keccak()}return this}finish(){if(this.finished)return;this.finished=!0;const{state:e,suffix:s,pos:n,blockLen:o}=this;e[n]^=s,s&128&&n===o-1&&this.keccak(),e[o-1]^=128,this.keccak()}writeInto(e){g(this,!1),y(e),this.finish();const s=this.state,{blockLen:n}=this;for(let o=0,i=e.length;o<i;){this.posOut>=n&&this.keccak();const r=Math.min(n-this.posOut,i-o);e.set(s.subarray(this.posOut,this.posOut+r),o),this.posOut+=r,o+=r}return e}xofInto(e){if(!this.enableXOF)throw new Error("XOF is not possible for this instance");return this.writeInto(e)}xof(e){return x(e),this.xofInto(new Uint8Array(e))}digestInto(e){if(z(e,this),this.finished)throw new Error("digest() was already called");return this.writeInto(e),this.destroy(),e}digest(){return this.digestInto(new Uint8Array(this.outputLen))}destroy(){this.destroyed=!0,this.state.fill(0)}_cloneInto(e){const{blockLen:s,suffix:n,outputLen:o,rounds:i,enableXOF:r}=this;return e||(e=new w(s,n,o,r,i)),e.state32.set(this.state32),e.pos=this.pos,e.posOut=this.posOut,e.finished=this.finished,e.rounds=i,e.suffix=n,e.outputLen=o,e.enableXOF=r,e.destroyed=this.destroyed,e}}const it=(t,e,s)=>K(()=>new w(e,t,s)),ot=it(1,136,256/8);function ct(t,e={}){const{as:s=typeof t=="string"?"Hex":"Bytes"}=e,n=ot(v(t));return s==="Bytes"?n:F(n)}const ut=/^0x[a-fA-F0-9]{40}$/;function U(t,e={}){const{strict:s=!0}=e;if(!ut.test(t))throw new B({address:t,cause:new ht});if(s){if(t.toLowerCase()===t)return;if(ft(t)!==t)throw new B({address:t,cause:new at})}}function ft(t){if(p.has(t))return p.get(t);U(t,{strict:!1});const e=t.substring(2).toLowerCase(),s=ct(P(e),{as:"Bytes"}),n=e.split("");for(let i=0;i<40;i+=2)s[i>>1]>>4>=8&&n[i]&&(n[i]=n[i].toUpperCase()),(s[i>>1]&15)>=8&&n[i+1]&&(n[i+1]=n[i+1].toUpperCase());const o=`0x${n.join("")}`;return p.set(t,o),o}function dt(t,e={}){const{strict:s=!0}=e??{};try{return U(t,{strict:s}),!0}catch{return!1}}class B extends b{constructor({address:e,cause:s}){super(`Address "${e}" is invalid.`,{cause:s}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"Address.InvalidAddressError"})}}class ht extends b{constructor(){super("Address is not a 20 byte (40 hexadecimal character) value."),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"Address.InvalidInputError"})}}class at extends b{constructor(){super("Address does not match its checksum counterpart."),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"Address.InvalidChecksumError"})}}export{B as I,U as a,ht as b,ct as k,dt as v};
