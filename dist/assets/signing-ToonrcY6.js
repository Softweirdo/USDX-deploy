import{a6 as Qt,z as De,D as Fe,F as ge,a7 as be,a8 as Ze,a9 as Jt,aa as Pe,V as je,g as zt,f as xt,ab as $e,Q as we}from"./allowance-CkC3v96T.js";import{concatHex as Ye}from"./concat-hex-D_eiUzN6.js";import{bi as te,af as Ke,bO as Ge,bP as We,bQ as Xe,bR as Qe,a7 as Je,be as tn,aE as en,bS as nn,ax as pe,aB as ee,az as rn,aA as tt,bT as ye,bI as on,aC as me,aU as xe}from"./index-Dhkg18n_.js";import{g as sn,p as Ee}from"./index-CXvjsy-f.js";import{e as an,v as cn,h as fn}from"./TypedData-DSaBoitM.js";import"./send-eip712-transaction-BJ6C8jOD.js";import"./eth_sendRawTransaction-DPdnXbFR.js";import"./Address-DNfsXJRa.js";const ne="/docs/contract/encodeFunctionData";function un(e){const{abi:n,args:t,functionName:r}=e;let o=n[0];if(r){const i=sn({abi:n,args:t,name:r});if(!i)throw new Qt(r,{docsPath:ne});o=i}if(o.type!=="function")throw new Qt(void 0,{docsPath:ne});return{abi:[o],functionName:De(Fe(o))}}function dn(e){const{args:n}=e,{abi:t,functionName:r}=(()=>{var c;return e.abi.length===1&&((c=e.functionName)!=null&&c.startsWith("0x"))?e:un(e)})(),o=t[0],i=r,s="inputs"in o&&o.inputs?ge(o.inputs,n??[]):void 0;return be([i,s??"0x"])}const re=[{inputs:[{name:"_signer",type:"address"},{name:"_hash",type:"bytes32"},{name:"_signature",type:"bytes"}],stateMutability:"nonpayable",type:"constructor"},{inputs:[{name:"_signer",type:"address"},{name:"_hash",type:"bytes32"},{name:"_signature",type:"bytes"}],outputs:[{type:"bool"}],stateMutability:"nonpayable",type:"function",name:"isValidSig"}],ln="0x608060405234801561001057600080fd5b5060405161069438038061069483398101604081905261002f9161051e565b600061003c848484610048565b9050806000526001601ff35b60007f64926492649264926492649264926492649264926492649264926492649264926100748361040c565b036101e7576000606080848060200190518101906100929190610577565b60405192955090935091506000906001600160a01b038516906100b69085906105dd565b6000604051808303816000865af19150503d80600081146100f3576040519150601f19603f3d011682016040523d82523d6000602084013e6100f8565b606091505b50509050876001600160a01b03163b60000361016057806101605760405162461bcd60e51b815260206004820152601e60248201527f5369676e617475726556616c696461746f723a206465706c6f796d656e74000060448201526064015b60405180910390fd5b604051630b135d3f60e11b808252906001600160a01b038a1690631626ba7e90610190908b9087906004016105f9565b602060405180830381865afa1580156101ad573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906101d19190610633565b6001600160e01b03191614945050505050610405565b6001600160a01b0384163b1561027a57604051630b135d3f60e11b808252906001600160a01b03861690631626ba7e9061022790879087906004016105f9565b602060405180830381865afa158015610244573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906102689190610633565b6001600160e01b031916149050610405565b81516041146102df5760405162461bcd60e51b815260206004820152603a602482015260008051602061067483398151915260448201527f3a20696e76616c6964207369676e6174757265206c656e6774680000000000006064820152608401610157565b6102e7610425565b5060208201516040808401518451859392600091859190811061030c5761030c61065d565b016020015160f81c9050601b811480159061032b57508060ff16601c14155b1561038c5760405162461bcd60e51b815260206004820152603b602482015260008051602061067483398151915260448201527f3a20696e76616c6964207369676e617475726520762076616c756500000000006064820152608401610157565b60408051600081526020810180835289905260ff83169181019190915260608101849052608081018390526001600160a01b0389169060019060a0016020604051602081039080840390855afa1580156103ea573d6000803e3d6000fd5b505050602060405103516001600160a01b0316149450505050505b9392505050565b600060208251101561041d57600080fd5b508051015190565b60405180606001604052806003906020820280368337509192915050565b6001600160a01b038116811461045857600080fd5b50565b634e487b7160e01b600052604160045260246000fd5b60005b8381101561048c578181015183820152602001610474565b50506000910152565b600082601f8301126104a657600080fd5b81516001600160401b038111156104bf576104bf61045b565b604051601f8201601f19908116603f011681016001600160401b03811182821017156104ed576104ed61045b565b60405281815283820160200185101561050557600080fd5b610516826020830160208701610471565b949350505050565b60008060006060848603121561053357600080fd5b835161053e81610443565b6020850151604086015191945092506001600160401b0381111561056157600080fd5b61056d86828701610495565b9150509250925092565b60008060006060848603121561058c57600080fd5b835161059781610443565b60208501519093506001600160401b038111156105b357600080fd5b6105bf86828701610495565b604086015190935090506001600160401b0381111561056157600080fd5b600082516105ef818460208701610471565b9190910192915050565b828152604060208201526000825180604084015261061e816060850160208701610471565b601f01601f1916919091016060019392505050565b60006020828403121561064557600080fd5b81516001600160e01b03198116811461040557600080fd5b634e487b7160e01b600052603260045260246000fdfe5369676e617475726556616c696461746f72237265636f7665725369676e6572",Lt="/docs/contract/encodeDeployData";function hn(e){const{abi:n,args:t,bytecode:r}=e;if(!t||t.length===0)return r;const o=n.find(s=>"type"in s&&s.type==="constructor");if(!o)throw new Ze({docsPath:Lt});if(!("inputs"in o))throw new Jt({docsPath:Lt});if(!o.inputs||o.inputs.length===0)throw new Jt({docsPath:Lt});const i=ge(o.inputs,t);return be([r,i])}const gn="0x6492649264926492649264926492649264926492649264926492649264926492";function bn(e){return Pe(e,-32)===gn}function oe(e){if(!Number.isSafeInteger(e)||e<0)throw new Error("positive integer expected, got "+e)}function wn(e){return e instanceof Uint8Array||ArrayBuffer.isView(e)&&e.constructor.name==="Uint8Array"}function St(e,...n){if(!wn(e))throw new Error("Uint8Array expected");if(n.length>0&&!n.includes(e.length))throw new Error("Uint8Array expected of length "+n+", got length="+e.length)}function pn(e){if(typeof e!="function"||typeof e.create!="function")throw new Error("Hash should be wrapped by utils.wrapConstructor");oe(e.outputLen),oe(e.blockLen)}function At(e,n=!0){if(e.destroyed)throw new Error("Hash instance has been destroyed");if(n&&e.finished)throw new Error("Hash#digest() has already been called")}function yn(e,n){St(e);const t=n.outputLen;if(e.length<t)throw new Error("digestInto() expects output buffer of length at least "+t)}const ut=typeof globalThis=="object"&&"crypto"in globalThis?globalThis.crypto:void 0;/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */const qt=e=>new DataView(e.buffer,e.byteOffset,e.byteLength),$=(e,n)=>e<<32-n|e>>>n;function mn(e){if(typeof e!="string")throw new Error("utf8ToBytes expected string, got "+typeof e);return new Uint8Array(new TextEncoder().encode(e))}function jt(e){return typeof e=="string"&&(e=mn(e)),St(e),e}function xn(...e){let n=0;for(let r=0;r<e.length;r++){const o=e[r];St(o),n+=o.length}const t=new Uint8Array(n);for(let r=0,o=0;r<e.length;r++){const i=e[r];t.set(i,o),o+=i.length}return t}class Be{clone(){return this._cloneInto()}}function En(e){const n=r=>e().update(jt(r)).digest(),t=e();return n.outputLen=t.outputLen,n.blockLen=t.blockLen,n.create=()=>e(),n}function Bn(e=32){if(ut&&typeof ut.getRandomValues=="function")return ut.getRandomValues(new Uint8Array(e));if(ut&&typeof ut.randomBytes=="function")return ut.randomBytes(e);throw new Error("crypto.getRandomValues must be defined")}function vn(e,n,t,r){if(typeof e.setBigUint64=="function")return e.setBigUint64(n,t,r);const o=BigInt(32),i=BigInt(4294967295),s=Number(t>>o&i),c=Number(t&i),a=r?4:0,u=r?0:4;e.setUint32(n+a,s,r),e.setUint32(n+u,c,r)}const An=(e,n,t)=>e&n^~e&t,Sn=(e,n,t)=>e&n^e&t^n&t;class In extends Be{constructor(n,t,r,o){super(),this.blockLen=n,this.outputLen=t,this.padOffset=r,this.isLE=o,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array(n),this.view=qt(this.buffer)}update(n){At(this);const{view:t,buffer:r,blockLen:o}=this;n=jt(n);const i=n.length;for(let s=0;s<i;){const c=Math.min(o-this.pos,i-s);if(c===o){const a=qt(n);for(;o<=i-s;s+=o)this.process(a,s);continue}r.set(n.subarray(s,s+c),this.pos),this.pos+=c,s+=c,this.pos===o&&(this.process(t,0),this.pos=0)}return this.length+=n.length,this.roundClean(),this}digestInto(n){At(this),yn(n,this),this.finished=!0;const{buffer:t,view:r,blockLen:o,isLE:i}=this;let{pos:s}=this;t[s++]=128,this.buffer.subarray(s).fill(0),this.padOffset>o-s&&(this.process(r,0),s=0);for(let l=s;l<o;l++)t[l]=0;vn(r,o-8,BigInt(this.length*8),i),this.process(r,0);const c=qt(n),a=this.outputLen;if(a%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const u=a/4,g=this.get();if(u>g.length)throw new Error("_sha2: outputLen bigger than state");for(let l=0;l<u;l++)c.setUint32(4*l,g[l],i)}digest(){const{buffer:n,outputLen:t}=this;this.digestInto(n);const r=n.slice(0,t);return this.destroy(),r}_cloneInto(n){n||(n=new this.constructor),n.set(...this.get());const{blockLen:t,buffer:r,length:o,finished:i,destroyed:s,pos:c}=this;return n.length=o,n.pos=c,n.finished=i,n.destroyed=s,o%t&&n.buffer.set(r),n}}const Tn=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),Q=new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),J=new Uint32Array(64);class Nn extends In{constructor(){super(64,32,8,!1),this.A=Q[0]|0,this.B=Q[1]|0,this.C=Q[2]|0,this.D=Q[3]|0,this.E=Q[4]|0,this.F=Q[5]|0,this.G=Q[6]|0,this.H=Q[7]|0}get(){const{A:n,B:t,C:r,D:o,E:i,F:s,G:c,H:a}=this;return[n,t,r,o,i,s,c,a]}set(n,t,r,o,i,s,c,a){this.A=n|0,this.B=t|0,this.C=r|0,this.D=o|0,this.E=i|0,this.F=s|0,this.G=c|0,this.H=a|0}process(n,t){for(let l=0;l<16;l++,t+=4)J[l]=n.getUint32(t,!1);for(let l=16;l<64;l++){const d=J[l-15],m=J[l-2],A=$(d,7)^$(d,18)^d>>>3,y=$(m,17)^$(m,19)^m>>>10;J[l]=y+J[l-7]+A+J[l-16]|0}let{A:r,B:o,C:i,D:s,E:c,F:a,G:u,H:g}=this;for(let l=0;l<64;l++){const d=$(c,6)^$(c,11)^$(c,25),m=g+d+An(c,a,u)+Tn[l]+J[l]|0,y=($(r,2)^$(r,13)^$(r,22))+Sn(r,o,i)|0;g=u,u=a,a=c,c=s+m|0,s=i,i=o,o=r,r=m+y|0}r=r+this.A|0,o=o+this.B|0,i=i+this.C|0,s=s+this.D|0,c=c+this.E|0,a=a+this.F|0,u=u+this.G|0,g=g+this.H|0,this.set(r,o,i,s,c,a,u,g)}roundClean(){J.fill(0)}destroy(){this.set(0,0,0,0,0,0,0,0),this.buffer.fill(0)}}const Hn=En(()=>new Nn);class ve extends Be{constructor(n,t){super(),this.finished=!1,this.destroyed=!1,pn(n);const r=jt(t);if(this.iHash=n.create(),typeof this.iHash.update!="function")throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const o=this.blockLen,i=new Uint8Array(o);i.set(r.length>o?n.create().update(r).digest():r);for(let s=0;s<i.length;s++)i[s]^=54;this.iHash.update(i),this.oHash=n.create();for(let s=0;s<i.length;s++)i[s]^=106;this.oHash.update(i),i.fill(0)}update(n){return At(this),this.iHash.update(n),this}digestInto(n){At(this),St(n,this.outputLen),this.finished=!0,this.iHash.digestInto(n),this.oHash.update(n),this.oHash.digestInto(n),this.destroy()}digest(){const n=new Uint8Array(this.oHash.outputLen);return this.digestInto(n),n}_cloneInto(n){n||(n=Object.create(Object.getPrototypeOf(this),{}));const{oHash:t,iHash:r,finished:o,destroyed:i,blockLen:s,outputLen:c}=this;return n=n,n.finished=o,n.destroyed=i,n.blockLen=s,n.outputLen=c,n.oHash=t._cloneInto(n.oHash),n.iHash=r._cloneInto(n.iHash),n}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}const Ae=(e,n,t)=>new ve(e,n).update(t).digest();Ae.create=(e,n)=>new ve(e,n);/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const It=BigInt(0),Tt=BigInt(1),On=BigInt(2);function st(e){return e instanceof Uint8Array||ArrayBuffer.isView(e)&&e.constructor.name==="Uint8Array"}function Et(e){if(!st(e))throw new Error("Uint8Array expected")}function lt(e,n){if(typeof n!="boolean")throw new Error(e+" boolean expected, got "+n)}const Ln=Array.from({length:256},(e,n)=>n.toString(16).padStart(2,"0"));function ht(e){Et(e);let n="";for(let t=0;t<e.length;t++)n+=Ln[e[t]];return n}function dt(e){const n=e.toString(16);return n.length&1?"0"+n:n}function $t(e){if(typeof e!="string")throw new Error("hex string expected, got "+typeof e);return e===""?It:BigInt("0x"+e)}const K={_0:48,_9:57,A:65,F:70,a:97,f:102};function ie(e){if(e>=K._0&&e<=K._9)return e-K._0;if(e>=K.A&&e<=K.F)return e-(K.A-10);if(e>=K.a&&e<=K.f)return e-(K.a-10)}function gt(e){if(typeof e!="string")throw new Error("hex string expected, got "+typeof e);const n=e.length,t=n/2;if(n%2)throw new Error("hex string expected, got unpadded hex of length "+n);const r=new Uint8Array(t);for(let o=0,i=0;o<t;o++,i+=2){const s=ie(e.charCodeAt(i)),c=ie(e.charCodeAt(i+1));if(s===void 0||c===void 0){const a=e[i]+e[i+1];throw new Error('hex string expected, got non-hex character "'+a+'" at index '+i)}r[o]=s*16+c}return r}function ot(e){return $t(ht(e))}function Yt(e){return Et(e),$t(ht(Uint8Array.from(e).reverse()))}function bt(e,n){return gt(e.toString(16).padStart(n*2,"0"))}function Kt(e,n){return bt(e,n).reverse()}function qn(e){return gt(dt(e))}function j(e,n,t){let r;if(typeof n=="string")try{r=gt(n)}catch(i){throw new Error(e+" must be hex string or Uint8Array, cause: "+i)}else if(st(n))r=Uint8Array.from(n);else throw new Error(e+" must be hex string or Uint8Array");const o=r.length;if(typeof t=="number"&&o!==t)throw new Error(e+" of length "+t+" expected, got "+o);return r}function mt(...e){let n=0;for(let r=0;r<e.length;r++){const o=e[r];Et(o),n+=o.length}const t=new Uint8Array(n);for(let r=0,o=0;r<e.length;r++){const i=e[r];t.set(i,o),o+=i.length}return t}function Un(e,n){if(e.length!==n.length)return!1;let t=0;for(let r=0;r<e.length;r++)t|=e[r]^n[r];return t===0}function _n(e){if(typeof e!="string")throw new Error("string expected");return new Uint8Array(new TextEncoder().encode(e))}const Ut=e=>typeof e=="bigint"&&It<=e;function Nt(e,n,t){return Ut(e)&&Ut(n)&&Ut(t)&&n<=e&&e<t}function it(e,n,t,r){if(!Nt(n,t,r))throw new Error("expected valid "+e+": "+t+" <= n < "+r+", got "+n)}function Se(e){let n;for(n=0;e>It;e>>=Tt,n+=1);return n}function Vn(e,n){return e>>BigInt(n)&Tt}function Cn(e,n,t){return e|(t?Tt:It)<<BigInt(n)}const Gt=e=>(On<<BigInt(e-1))-Tt,_t=e=>new Uint8Array(e),se=e=>Uint8Array.from(e);function Ie(e,n,t){if(typeof e!="number"||e<2)throw new Error("hashLen must be a number");if(typeof n!="number"||n<2)throw new Error("qByteLen must be a number");if(typeof t!="function")throw new Error("hmacFn must be a function");let r=_t(e),o=_t(e),i=0;const s=()=>{r.fill(1),o.fill(0),i=0},c=(...l)=>t(o,r,...l),a=(l=_t())=>{o=c(se([0]),l),r=c(),l.length!==0&&(o=c(se([1]),l),r=c())},u=()=>{if(i++>=1e3)throw new Error("drbg: tried 1000 values");let l=0;const d=[];for(;l<n;){r=c();const m=r.slice();d.push(m),l+=r.length}return mt(...d)};return(l,d)=>{s(),a(l);let m;for(;!(m=d(u()));)a();return s(),m}}const kn={bigint:e=>typeof e=="bigint",function:e=>typeof e=="function",boolean:e=>typeof e=="boolean",string:e=>typeof e=="string",stringOrUint8Array:e=>typeof e=="string"||st(e),isSafeInteger:e=>Number.isSafeInteger(e),array:e=>Array.isArray(e),field:(e,n)=>n.Fp.isValid(e),hash:e=>typeof e=="function"&&Number.isSafeInteger(e.outputLen)};function Bt(e,n,t={}){const r=(o,i,s)=>{const c=kn[i];if(typeof c!="function")throw new Error("invalid validator function");const a=e[o];if(!(s&&a===void 0)&&!c(a,e))throw new Error("param "+String(o)+" is invalid. Expected "+i+", got "+a)};for(const[o,i]of Object.entries(n))r(o,i,!1);for(const[o,i]of Object.entries(t))r(o,i,!0);return e}const Mn=()=>{throw new Error("not implemented")};function Rt(e){const n=new WeakMap;return(t,...r)=>{const o=n.get(t);if(o!==void 0)return o;const i=e(t,...r);return n.set(t,i),i}}const zn=Object.freeze(Object.defineProperty({__proto__:null,aInRange:it,abool:lt,abytes:Et,bitGet:Vn,bitLen:Se,bitMask:Gt,bitSet:Cn,bytesToHex:ht,bytesToNumberBE:ot,bytesToNumberLE:Yt,concatBytes:mt,createHmacDrbg:Ie,ensureBytes:j,equalBytes:Un,hexToBytes:gt,hexToNumber:$t,inRange:Nt,isBytes:st,memoized:Rt,notImplemented:Mn,numberToBytesBE:bt,numberToBytesLE:Kt,numberToHexUnpadded:dt,numberToVarBytesBE:qn,utf8ToBytes:_n,validateObject:Bt},Symbol.toStringTag,{value:"Module"}));/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const C=BigInt(0),U=BigInt(1),rt=BigInt(2),Rn=BigInt(3),Dt=BigInt(4),ae=BigInt(5),ce=BigInt(8);function D(e,n){const t=e%n;return t>=C?t:n+t}function Dn(e,n,t){if(n<C)throw new Error("invalid exponent, negatives unsupported");if(t<=C)throw new Error("invalid modulus");if(t===U)return C;let r=U;for(;n>C;)n&U&&(r=r*e%t),e=e*e%t,n>>=U;return r}function Z(e,n,t){let r=e;for(;n-- >C;)r*=r,r%=t;return r}function Ft(e,n){if(e===C)throw new Error("invert: expected non-zero number");if(n<=C)throw new Error("invert: expected positive modulus, got "+n);let t=D(e,n),r=n,o=C,i=U;for(;t!==C;){const c=r/t,a=r%t,u=o-i*c;r=t,t=a,o=i,i=u}if(r!==U)throw new Error("invert: does not exist");return D(o,n)}function Fn(e){const n=(e-U)/rt;let t,r,o;for(t=e-U,r=0;t%rt===C;t/=rt,r++);for(o=rt;o<e&&Dn(o,n,e)!==e-U;o++)if(o>1e3)throw new Error("Cannot find square root: likely non-prime P");if(r===1){const s=(e+U)/Dt;return function(a,u){const g=a.pow(u,s);if(!a.eql(a.sqr(g),u))throw new Error("Cannot find square root");return g}}const i=(t+U)/rt;return function(c,a){if(c.pow(a,n)===c.neg(c.ONE))throw new Error("Cannot find square root");let u=r,g=c.pow(c.mul(c.ONE,o),t),l=c.pow(a,i),d=c.pow(a,t);for(;!c.eql(d,c.ONE);){if(c.eql(d,c.ZERO))return c.ZERO;let m=1;for(let y=c.sqr(d);m<u&&!c.eql(y,c.ONE);m++)y=c.sqr(y);const A=c.pow(g,U<<BigInt(u-m-1));g=c.sqr(A),l=c.mul(l,A),d=c.mul(d,g),u=m}return l}}function Zn(e){if(e%Dt===Rn){const n=(e+U)/Dt;return function(r,o){const i=r.pow(o,n);if(!r.eql(r.sqr(i),o))throw new Error("Cannot find square root");return i}}if(e%ce===ae){const n=(e-ae)/ce;return function(r,o){const i=r.mul(o,rt),s=r.pow(i,n),c=r.mul(o,s),a=r.mul(r.mul(c,rt),s),u=r.mul(c,r.sub(a,r.ONE));if(!r.eql(r.sqr(u),o))throw new Error("Cannot find square root");return u}}return Fn(e)}const Pn=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function jn(e){const n={ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"},t=Pn.reduce((r,o)=>(r[o]="function",r),n);return Bt(e,t)}function $n(e,n,t){if(t<C)throw new Error("invalid exponent, negatives unsupported");if(t===C)return e.ONE;if(t===U)return n;let r=e.ONE,o=n;for(;t>C;)t&U&&(r=e.mul(r,o)),o=e.sqr(o),t>>=U;return r}function Yn(e,n){const t=new Array(n.length),r=n.reduce((i,s,c)=>e.is0(s)?i:(t[c]=i,e.mul(i,s)),e.ONE),o=e.inv(r);return n.reduceRight((i,s,c)=>e.is0(s)?i:(t[c]=e.mul(i,t[c]),e.mul(i,s)),o),t}function Te(e,n){const t=n!==void 0?n:e.toString(2).length,r=Math.ceil(t/8);return{nBitLength:t,nByteLength:r}}function Ne(e,n,t=!1,r={}){if(e<=C)throw new Error("invalid field: expected ORDER > 0, got "+e);const{nBitLength:o,nByteLength:i}=Te(e,n);if(i>2048)throw new Error("invalid field: expected ORDER of <= 2048 bytes");let s;const c=Object.freeze({ORDER:e,BITS:o,BYTES:i,MASK:Gt(o),ZERO:C,ONE:U,create:a=>D(a,e),isValid:a=>{if(typeof a!="bigint")throw new Error("invalid field element: expected bigint, got "+typeof a);return C<=a&&a<e},is0:a=>a===C,isOdd:a=>(a&U)===U,neg:a=>D(-a,e),eql:(a,u)=>a===u,sqr:a=>D(a*a,e),add:(a,u)=>D(a+u,e),sub:(a,u)=>D(a-u,e),mul:(a,u)=>D(a*u,e),pow:(a,u)=>$n(c,a,u),div:(a,u)=>D(a*Ft(u,e),e),sqrN:a=>a*a,addN:(a,u)=>a+u,subN:(a,u)=>a-u,mulN:(a,u)=>a*u,inv:a=>Ft(a,e),sqrt:r.sqrt||(a=>(s||(s=Zn(e)),s(c,a))),invertBatch:a=>Yn(c,a),cmov:(a,u,g)=>g?u:a,toBytes:a=>t?Kt(a,i):bt(a,i),fromBytes:a=>{if(a.length!==i)throw new Error("Field.fromBytes: expected "+i+" bytes, got "+a.length);return t?Yt(a):ot(a)}});return Object.freeze(c)}function He(e){if(typeof e!="bigint")throw new Error("field order must be bigint");const n=e.toString(2).length;return Math.ceil(n/8)}function Oe(e){const n=He(e);return n+Math.ceil(n/2)}function Kn(e,n,t=!1){const r=e.length,o=He(n),i=Oe(n);if(r<16||r<i||r>1024)throw new Error("expected "+i+"-1024 bytes of input, got "+r);const s=t?ot(e):Yt(e),c=D(s,n-U)+U;return t?Kt(c,o):bt(c,o)}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const fe=BigInt(0),vt=BigInt(1);function Vt(e,n){const t=n.negate();return e?t:n}function Le(e,n){if(!Number.isSafeInteger(e)||e<=0||e>n)throw new Error("invalid window size, expected [1.."+n+"], got W="+e)}function Ct(e,n){Le(e,n);const t=Math.ceil(n/e)+1,r=2**(e-1);return{windows:t,windowSize:r}}function Gn(e,n){if(!Array.isArray(e))throw new Error("array expected");e.forEach((t,r)=>{if(!(t instanceof n))throw new Error("invalid point at index "+r)})}function Wn(e,n){if(!Array.isArray(e))throw new Error("array of scalars expected");e.forEach((t,r)=>{if(!n.isValid(t))throw new Error("invalid scalar at index "+r)})}const kt=new WeakMap,qe=new WeakMap;function Mt(e){return qe.get(e)||1}function Xn(e,n){return{constTimeNegate:Vt,hasPrecomputes(t){return Mt(t)!==1},unsafeLadder(t,r,o=e.ZERO){let i=t;for(;r>fe;)r&vt&&(o=o.add(i)),i=i.double(),r>>=vt;return o},precomputeWindow(t,r){const{windows:o,windowSize:i}=Ct(r,n),s=[];let c=t,a=c;for(let u=0;u<o;u++){a=c,s.push(a);for(let g=1;g<i;g++)a=a.add(c),s.push(a);c=a.double()}return s},wNAF(t,r,o){const{windows:i,windowSize:s}=Ct(t,n);let c=e.ZERO,a=e.BASE;const u=BigInt(2**t-1),g=2**t,l=BigInt(t);for(let d=0;d<i;d++){const m=d*s;let A=Number(o&u);o>>=l,A>s&&(A-=g,o+=vt);const y=m,f=m+Math.abs(A)-1,b=d%2!==0,x=A<0;A===0?a=a.add(Vt(b,r[y])):c=c.add(Vt(x,r[f]))}return{p:c,f:a}},wNAFUnsafe(t,r,o,i=e.ZERO){const{windows:s,windowSize:c}=Ct(t,n),a=BigInt(2**t-1),u=2**t,g=BigInt(t);for(let l=0;l<s;l++){const d=l*c;if(o===fe)break;let m=Number(o&a);if(o>>=g,m>c&&(m-=u,o+=vt),m===0)continue;let A=r[d+Math.abs(m)-1];m<0&&(A=A.negate()),i=i.add(A)}return i},getPrecomputes(t,r,o){let i=kt.get(r);return i||(i=this.precomputeWindow(r,t),t!==1&&kt.set(r,o(i))),i},wNAFCached(t,r,o){const i=Mt(t);return this.wNAF(i,this.getPrecomputes(i,t,o),r)},wNAFCachedUnsafe(t,r,o,i){const s=Mt(t);return s===1?this.unsafeLadder(t,r,i):this.wNAFUnsafe(s,this.getPrecomputes(s,t,o),r,i)},setWindowSize(t,r){Le(r,n),qe.set(t,r),kt.delete(t)}}}function Qn(e,n,t,r){if(Gn(t,e),Wn(r,n),t.length!==r.length)throw new Error("arrays of points and scalars must have equal length");const o=e.ZERO,i=Se(BigInt(t.length)),s=i>12?i-3:i>4?i-2:i?2:1,c=(1<<s)-1,a=new Array(c+1).fill(o),u=Math.floor((n.BITS-1)/s)*s;let g=o;for(let l=u;l>=0;l-=s){a.fill(o);for(let m=0;m<r.length;m++){const A=r[m],y=Number(A>>BigInt(l)&BigInt(c));a[y]=a[y].add(t[m])}let d=o;for(let m=a.length-1,A=o;m>0;m--)A=A.add(a[m]),d=d.add(A);if(g=g.add(d),l!==0)for(let m=0;m<s;m++)g=g.double()}return g}function Ue(e){return jn(e.Fp),Bt(e,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"}),Object.freeze({...Te(e.n,e.nBitLength),...e,p:e.Fp.ORDER})}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function ue(e){e.lowS!==void 0&&lt("lowS",e.lowS),e.prehash!==void 0&&lt("prehash",e.prehash)}function Jn(e){const n=Ue(e);Bt(n,{a:"field",b:"field"},{allowedPrivateKeyLengths:"array",wrapPrivateKey:"boolean",isTorsionFree:"function",clearCofactor:"function",allowInfinityPoint:"boolean",fromBytes:"function",toBytes:"function"});const{endo:t,Fp:r,a:o}=n;if(t){if(!r.eql(o,r.ZERO))throw new Error("invalid endomorphism, can only be defined for Koblitz curves that have a=0");if(typeof t!="object"||typeof t.beta!="bigint"||typeof t.splitScalar!="function")throw new Error("invalid endomorphism, expected beta: bigint and splitScalar: function")}return Object.freeze({...n})}const{bytesToNumberBE:tr,hexToBytes:er}=zn,G={Err:class extends Error{constructor(n=""){super(n)}},_tlv:{encode:(e,n)=>{const{Err:t}=G;if(e<0||e>256)throw new t("tlv.encode: wrong tag");if(n.length&1)throw new t("tlv.encode: unpadded data");const r=n.length/2,o=dt(r);if(o.length/2&128)throw new t("tlv.encode: long form length too big");const i=r>127?dt(o.length/2|128):"";return dt(e)+i+o+n},decode(e,n){const{Err:t}=G;let r=0;if(e<0||e>256)throw new t("tlv.encode: wrong tag");if(n.length<2||n[r++]!==e)throw new t("tlv.decode: wrong tlv");const o=n[r++],i=!!(o&128);let s=0;if(!i)s=o;else{const a=o&127;if(!a)throw new t("tlv.decode(long): indefinite length not supported");if(a>4)throw new t("tlv.decode(long): byte length is too big");const u=n.subarray(r,r+a);if(u.length!==a)throw new t("tlv.decode: length bytes not complete");if(u[0]===0)throw new t("tlv.decode(long): zero leftmost byte");for(const g of u)s=s<<8|g;if(r+=a,s<128)throw new t("tlv.decode(long): not minimal encoding")}const c=n.subarray(r,r+s);if(c.length!==s)throw new t("tlv.decode: wrong value length");return{v:c,l:n.subarray(r+s)}}},_int:{encode(e){const{Err:n}=G;if(e<W)throw new n("integer: negative integers are not allowed");let t=dt(e);if(Number.parseInt(t[0],16)&8&&(t="00"+t),t.length&1)throw new n("unexpected DER parsing assertion: unpadded hex");return t},decode(e){const{Err:n}=G;if(e[0]&128)throw new n("invalid signature integer: negative");if(e[0]===0&&!(e[1]&128))throw new n("invalid signature integer: unnecessary leading zero");return tr(e)}},toSig(e){const{Err:n,_int:t,_tlv:r}=G,o=typeof e=="string"?er(e):e;Et(o);const{v:i,l:s}=r.decode(48,o);if(s.length)throw new n("invalid signature: left bytes after parsing");const{v:c,l:a}=r.decode(2,i),{v:u,l:g}=r.decode(2,a);if(g.length)throw new n("invalid signature: left bytes after parsing");return{r:t.decode(c),s:t.decode(u)}},hexFromSig(e){const{_tlv:n,_int:t}=G,r=n.encode(2,t.encode(e.r)),o=n.encode(2,t.encode(e.s)),i=r+o;return n.encode(48,i)}},W=BigInt(0),V=BigInt(1);BigInt(2);const de=BigInt(3);BigInt(4);function nr(e){const n=Jn(e),{Fp:t}=n,r=Ne(n.n,n.nBitLength),o=n.toBytes||((y,f,b)=>{const x=f.toAffine();return mt(Uint8Array.from([4]),t.toBytes(x.x),t.toBytes(x.y))}),i=n.fromBytes||(y=>{const f=y.subarray(1),b=t.fromBytes(f.subarray(0,t.BYTES)),x=t.fromBytes(f.subarray(t.BYTES,2*t.BYTES));return{x:b,y:x}});function s(y){const{a:f,b}=n,x=t.sqr(y),E=t.mul(x,y);return t.add(t.add(E,t.mul(y,f)),b)}if(!t.eql(t.sqr(n.Gy),s(n.Gx)))throw new Error("bad generator point: equation left != right");function c(y){return Nt(y,V,n.n)}function a(y){const{allowedPrivateKeyLengths:f,nByteLength:b,wrapPrivateKey:x,n:E}=n;if(f&&typeof y!="bigint"){if(st(y)&&(y=ht(y)),typeof y!="string"||!f.includes(y.length))throw new Error("invalid private key");y=y.padStart(b*2,"0")}let N;try{N=typeof y=="bigint"?y:ot(j("private key",y,b))}catch{throw new Error("invalid private key, expected hex or "+b+" bytes, got "+typeof y)}return x&&(N=D(N,E)),it("private key",N,V,E),N}function u(y){if(!(y instanceof d))throw new Error("ProjectivePoint expected")}const g=Rt((y,f)=>{const{px:b,py:x,pz:E}=y;if(t.eql(E,t.ONE))return{x:b,y:x};const N=y.is0();f==null&&(f=N?t.ONE:t.inv(E));const O=t.mul(b,f),T=t.mul(x,f),B=t.mul(E,f);if(N)return{x:t.ZERO,y:t.ZERO};if(!t.eql(B,t.ONE))throw new Error("invZ was invalid");return{x:O,y:T}}),l=Rt(y=>{if(y.is0()){if(n.allowInfinityPoint&&!t.is0(y.py))return;throw new Error("bad point: ZERO")}const{x:f,y:b}=y.toAffine();if(!t.isValid(f)||!t.isValid(b))throw new Error("bad point: x or y not FE");const x=t.sqr(b),E=s(f);if(!t.eql(x,E))throw new Error("bad point: equation left != right");if(!y.isTorsionFree())throw new Error("bad point: not in prime-order subgroup");return!0});class d{constructor(f,b,x){if(this.px=f,this.py=b,this.pz=x,f==null||!t.isValid(f))throw new Error("x required");if(b==null||!t.isValid(b))throw new Error("y required");if(x==null||!t.isValid(x))throw new Error("z required");Object.freeze(this)}static fromAffine(f){const{x:b,y:x}=f||{};if(!f||!t.isValid(b)||!t.isValid(x))throw new Error("invalid affine point");if(f instanceof d)throw new Error("projective point not allowed");const E=N=>t.eql(N,t.ZERO);return E(b)&&E(x)?d.ZERO:new d(b,x,t.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(f){const b=t.invertBatch(f.map(x=>x.pz));return f.map((x,E)=>x.toAffine(b[E])).map(d.fromAffine)}static fromHex(f){const b=d.fromAffine(i(j("pointHex",f)));return b.assertValidity(),b}static fromPrivateKey(f){return d.BASE.multiply(a(f))}static msm(f,b){return Qn(d,r,f,b)}_setWindowSize(f){A.setWindowSize(this,f)}assertValidity(){l(this)}hasEvenY(){const{y:f}=this.toAffine();if(t.isOdd)return!t.isOdd(f);throw new Error("Field doesn't support isOdd")}equals(f){u(f);const{px:b,py:x,pz:E}=this,{px:N,py:O,pz:T}=f,B=t.eql(t.mul(b,T),t.mul(N,E)),I=t.eql(t.mul(x,T),t.mul(O,E));return B&&I}negate(){return new d(this.px,t.neg(this.py),this.pz)}double(){const{a:f,b}=n,x=t.mul(b,de),{px:E,py:N,pz:O}=this;let T=t.ZERO,B=t.ZERO,I=t.ZERO,v=t.mul(E,E),k=t.mul(N,N),q=t.mul(O,O),L=t.mul(E,N);return L=t.add(L,L),I=t.mul(E,O),I=t.add(I,I),T=t.mul(f,I),B=t.mul(x,q),B=t.add(T,B),T=t.sub(k,B),B=t.add(k,B),B=t.mul(T,B),T=t.mul(L,T),I=t.mul(x,I),q=t.mul(f,q),L=t.sub(v,q),L=t.mul(f,L),L=t.add(L,I),I=t.add(v,v),v=t.add(I,v),v=t.add(v,q),v=t.mul(v,L),B=t.add(B,v),q=t.mul(N,O),q=t.add(q,q),v=t.mul(q,L),T=t.sub(T,v),I=t.mul(q,k),I=t.add(I,I),I=t.add(I,I),new d(T,B,I)}add(f){u(f);const{px:b,py:x,pz:E}=this,{px:N,py:O,pz:T}=f;let B=t.ZERO,I=t.ZERO,v=t.ZERO;const k=n.a,q=t.mul(n.b,de);let L=t.mul(b,N),F=t.mul(x,O),h=t.mul(E,T),w=t.add(b,x),p=t.add(N,O);w=t.mul(w,p),p=t.add(L,F),w=t.sub(w,p),p=t.add(b,E);let S=t.add(N,T);return p=t.mul(p,S),S=t.add(L,h),p=t.sub(p,S),S=t.add(x,E),B=t.add(O,T),S=t.mul(S,B),B=t.add(F,h),S=t.sub(S,B),v=t.mul(k,p),B=t.mul(q,h),v=t.add(B,v),B=t.sub(F,v),v=t.add(F,v),I=t.mul(B,v),F=t.add(L,L),F=t.add(F,L),h=t.mul(k,h),p=t.mul(q,p),F=t.add(F,h),h=t.sub(L,h),h=t.mul(k,h),p=t.add(p,h),L=t.mul(F,p),I=t.add(I,L),L=t.mul(S,p),B=t.mul(w,B),B=t.sub(B,L),L=t.mul(w,F),v=t.mul(S,v),v=t.add(v,L),new d(B,I,v)}subtract(f){return this.add(f.negate())}is0(){return this.equals(d.ZERO)}wNAF(f){return A.wNAFCached(this,f,d.normalizeZ)}multiplyUnsafe(f){const{endo:b,n:x}=n;it("scalar",f,W,x);const E=d.ZERO;if(f===W)return E;if(this.is0()||f===V)return this;if(!b||A.hasPrecomputes(this))return A.wNAFCachedUnsafe(this,f,d.normalizeZ);let{k1neg:N,k1:O,k2neg:T,k2:B}=b.splitScalar(f),I=E,v=E,k=this;for(;O>W||B>W;)O&V&&(I=I.add(k)),B&V&&(v=v.add(k)),k=k.double(),O>>=V,B>>=V;return N&&(I=I.negate()),T&&(v=v.negate()),v=new d(t.mul(v.px,b.beta),v.py,v.pz),I.add(v)}multiply(f){const{endo:b,n:x}=n;it("scalar",f,V,x);let E,N;if(b){const{k1neg:O,k1:T,k2neg:B,k2:I}=b.splitScalar(f);let{p:v,f:k}=this.wNAF(T),{p:q,f:L}=this.wNAF(I);v=A.constTimeNegate(O,v),q=A.constTimeNegate(B,q),q=new d(t.mul(q.px,b.beta),q.py,q.pz),E=v.add(q),N=k.add(L)}else{const{p:O,f:T}=this.wNAF(f);E=O,N=T}return d.normalizeZ([E,N])[0]}multiplyAndAddUnsafe(f,b,x){const E=d.BASE,N=(T,B)=>B===W||B===V||!T.equals(E)?T.multiplyUnsafe(B):T.multiply(B),O=N(this,b).add(N(f,x));return O.is0()?void 0:O}toAffine(f){return g(this,f)}isTorsionFree(){const{h:f,isTorsionFree:b}=n;if(f===V)return!0;if(b)return b(d,this);throw new Error("isTorsionFree() has not been declared for the elliptic curve")}clearCofactor(){const{h:f,clearCofactor:b}=n;return f===V?this:b?b(d,this):this.multiplyUnsafe(n.h)}toRawBytes(f=!0){return lt("isCompressed",f),this.assertValidity(),o(d,this,f)}toHex(f=!0){return lt("isCompressed",f),ht(this.toRawBytes(f))}}d.BASE=new d(n.Gx,n.Gy,t.ONE),d.ZERO=new d(t.ZERO,t.ONE,t.ZERO);const m=n.nBitLength,A=Xn(d,n.endo?Math.ceil(m/2):m);return{CURVE:n,ProjectivePoint:d,normPrivateKeyToScalar:a,weierstrassEquation:s,isWithinCurveOrder:c}}function rr(e){const n=Ue(e);return Bt(n,{hash:"hash",hmac:"function",randomBytes:"function"},{bits2int:"function",bits2int_modN:"function",lowS:"boolean"}),Object.freeze({lowS:!0,...n})}function or(e){const n=rr(e),{Fp:t,n:r}=n,o=t.BYTES+1,i=2*t.BYTES+1;function s(h){return D(h,r)}function c(h){return Ft(h,r)}const{ProjectivePoint:a,normPrivateKeyToScalar:u,weierstrassEquation:g,isWithinCurveOrder:l}=nr({...n,toBytes(h,w,p){const S=w.toAffine(),H=t.toBytes(S.x),_=mt;return lt("isCompressed",p),p?_(Uint8Array.from([w.hasEvenY()?2:3]),H):_(Uint8Array.from([4]),H,t.toBytes(S.y))},fromBytes(h){const w=h.length,p=h[0],S=h.subarray(1);if(w===o&&(p===2||p===3)){const H=ot(S);if(!Nt(H,V,t.ORDER))throw new Error("Point is not on curve");const _=g(H);let z;try{z=t.sqrt(_)}catch(P){const R=P instanceof Error?": "+P.message:"";throw new Error("Point is not on curve"+R)}const M=(z&V)===V;return(p&1)===1!==M&&(z=t.neg(z)),{x:H,y:z}}else if(w===i&&p===4){const H=t.fromBytes(S.subarray(0,t.BYTES)),_=t.fromBytes(S.subarray(t.BYTES,2*t.BYTES));return{x:H,y:_}}else{const H=o,_=i;throw new Error("invalid Point, expected length of "+H+", or uncompressed "+_+", got "+w)}}}),d=h=>ht(bt(h,n.nByteLength));function m(h){const w=r>>V;return h>w}function A(h){return m(h)?s(-h):h}const y=(h,w,p)=>ot(h.slice(w,p));class f{constructor(w,p,S){this.r=w,this.s=p,this.recovery=S,this.assertValidity()}static fromCompact(w){const p=n.nByteLength;return w=j("compactSignature",w,p*2),new f(y(w,0,p),y(w,p,2*p))}static fromDER(w){const{r:p,s:S}=G.toSig(j("DER",w));return new f(p,S)}assertValidity(){it("r",this.r,V,r),it("s",this.s,V,r)}addRecoveryBit(w){return new f(this.r,this.s,w)}recoverPublicKey(w){const{r:p,s:S,recovery:H}=this,_=T(j("msgHash",w));if(H==null||![0,1,2,3].includes(H))throw new Error("recovery id invalid");const z=H===2||H===3?p+n.n:p;if(z>=t.ORDER)throw new Error("recovery id 2 or 3 invalid");const M=H&1?"03":"02",Y=a.fromHex(M+d(z)),P=c(z),R=s(-_*P),at=s(S*P),X=a.BASE.multiplyAndAddUnsafe(Y,R,at);if(!X)throw new Error("point at infinify");return X.assertValidity(),X}hasHighS(){return m(this.s)}normalizeS(){return this.hasHighS()?new f(this.r,s(-this.s),this.recovery):this}toDERRawBytes(){return gt(this.toDERHex())}toDERHex(){return G.hexFromSig({r:this.r,s:this.s})}toCompactRawBytes(){return gt(this.toCompactHex())}toCompactHex(){return d(this.r)+d(this.s)}}const b={isValidPrivateKey(h){try{return u(h),!0}catch{return!1}},normPrivateKeyToScalar:u,randomPrivateKey:()=>{const h=Oe(n.n);return Kn(n.randomBytes(h),n.n)},precompute(h=8,w=a.BASE){return w._setWindowSize(h),w.multiply(BigInt(3)),w}};function x(h,w=!0){return a.fromPrivateKey(h).toRawBytes(w)}function E(h){const w=st(h),p=typeof h=="string",S=(w||p)&&h.length;return w?S===o||S===i:p?S===2*o||S===2*i:h instanceof a}function N(h,w,p=!0){if(E(h))throw new Error("first arg must be private key");if(!E(w))throw new Error("second arg must be public key");return a.fromHex(w).multiply(u(h)).toRawBytes(p)}const O=n.bits2int||function(h){if(h.length>8192)throw new Error("input is too large");const w=ot(h),p=h.length*8-n.nBitLength;return p>0?w>>BigInt(p):w},T=n.bits2int_modN||function(h){return s(O(h))},B=Gt(n.nBitLength);function I(h){return it("num < 2^"+n.nBitLength,h,W,B),bt(h,n.nByteLength)}function v(h,w,p=k){if(["recovered","canonical"].some(et=>et in p))throw new Error("sign() legacy options not supported");const{hash:S,randomBytes:H}=n;let{lowS:_,prehash:z,extraEntropy:M}=p;_==null&&(_=!0),h=j("msgHash",h),ue(p),z&&(h=j("prehashed msgHash",S(h)));const Y=T(h),P=u(w),R=[I(P),I(Y)];if(M!=null&&M!==!1){const et=M===!0?H(t.BYTES):M;R.push(j("extraEntropy",et))}const at=mt(...R),X=Y;function Ht(et){const ct=O(et);if(!l(ct))return;const Ot=c(ct),wt=a.BASE.multiply(ct).toAffine(),nt=s(wt.x);if(nt===W)return;const pt=s(Ot*s(X+nt*P));if(pt===W)return;let yt=(wt.x===nt?0:2)|Number(wt.y&V),ft=pt;return _&&m(pt)&&(ft=A(pt),yt^=1),new f(nt,ft,yt)}return{seed:at,k2sig:Ht}}const k={lowS:n.lowS,prehash:!1},q={lowS:n.lowS,prehash:!1};function L(h,w,p=k){const{seed:S,k2sig:H}=v(h,w,p),_=n;return Ie(_.hash.outputLen,_.nByteLength,_.hmac)(S,H)}a.BASE._setWindowSize(8);function F(h,w,p,S=q){var yt;const H=h;w=j("msgHash",w),p=j("publicKey",p);const{lowS:_,prehash:z,format:M}=S;if(ue(S),"strict"in S)throw new Error("options.strict was renamed to lowS");if(M!==void 0&&M!=="compact"&&M!=="der")throw new Error("format must be compact or der");const Y=typeof H=="string"||st(H),P=!Y&&!M&&typeof H=="object"&&H!==null&&typeof H.r=="bigint"&&typeof H.s=="bigint";if(!Y&&!P)throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");let R,at;try{if(P&&(R=new f(H.r,H.s)),Y){try{M!=="compact"&&(R=f.fromDER(H))}catch(ft){if(!(ft instanceof G.Err))throw ft}!R&&M!=="der"&&(R=f.fromCompact(H))}at=a.fromHex(p)}catch{return!1}if(!R||_&&R.hasHighS())return!1;z&&(w=n.hash(w));const{r:X,s:Ht}=R,et=T(w),ct=c(Ht),Ot=s(et*ct),wt=s(X*ct),nt=(yt=a.BASE.multiplyAndAddUnsafe(at,Ot,wt))==null?void 0:yt.toAffine();return nt?s(nt.x)===X:!1}return{CURVE:n,getPublicKey:x,getSharedSecret:N,sign:L,verify:F,ProjectivePoint:a,Signature:f,utils:b}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function ir(e){return{hash:e,hmac:(n,...t)=>Ae(e,n,xn(...t)),randomBytes:Bn}}function sr(e,n){const t=r=>or({...e,...ir(r)});return Object.freeze({...t(n),create:t})}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const _e=BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),le=BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),ar=BigInt(1),Zt=BigInt(2),he=(e,n)=>(e+n/Zt)/n;function cr(e){const n=_e,t=BigInt(3),r=BigInt(6),o=BigInt(11),i=BigInt(22),s=BigInt(23),c=BigInt(44),a=BigInt(88),u=e*e*e%n,g=u*u*e%n,l=Z(g,t,n)*g%n,d=Z(l,t,n)*g%n,m=Z(d,Zt,n)*u%n,A=Z(m,o,n)*m%n,y=Z(A,i,n)*A%n,f=Z(y,c,n)*y%n,b=Z(f,a,n)*f%n,x=Z(b,c,n)*y%n,E=Z(x,t,n)*g%n,N=Z(E,s,n)*A%n,O=Z(N,r,n)*u%n,T=Z(O,Zt,n);if(!Pt.eql(Pt.sqr(T),e))throw new Error("Cannot find square root");return T}const Pt=Ne(_e,void 0,void 0,{sqrt:cr}),Ve=sr({a:BigInt(0),b:BigInt(7),Fp:Pt,n:le,Gx:BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),Gy:BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),h:BigInt(1),lowS:!0,endo:{beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),splitScalar:e=>{const n=le,t=BigInt("0x3086d221a7d46bcde86c90e49284eb15"),r=-ar*BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),o=BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),i=t,s=BigInt("0x100000000000000000000000000000000"),c=he(i*e,n),a=he(-r*e,n);let u=D(e-c*t-a*o,n),g=D(-c*r-a*i,n);const l=u>s,d=g>s;if(l&&(u=n-u),d&&(g=n-g),u>s||g>s)throw new Error("splitScalar: Endomorphism failed, k="+e);return{k1neg:l,k1:u,k2neg:d,k2:g}}}},Hn);BigInt(0);Ve.ProjectivePoint;function fr({r:e,s:n,to:t="hex",v:r,yParity:o}){const i=(()=>{if(o===0||o===1)return o;if(r&&(r===27n||r===28n||r>=35n))return r%2n===0n?1:0;throw new Error("Invalid `v` or `yParity` value")})(),s=`0x${new Ve.Signature(te(e),te(n)).toCompactHex()}${i===0?"1b":"1c"}`;return t==="hex"?s:je(s)}function ur(e,n){const t={to:n};switch(t.to){case"number":return hr(e,t);case"bigint":return dr(e,t);case"boolean":return lr(e,t);case"string":return gr(e,t);default:return Ke(e,t)}}function dr(e,n={}){return Ge(e,n)}function lr(e,n={}){return We(e,n)}function hr(e,n={}){return Xe(e,n)}function gr(e,n={}){return Qe(e,n)}const br="0x1626ba7e",wr=[{type:"bytes32",name:"hash"},{type:"bytes",name:"signature"}],pr=[{type:"bytes4"}];async function yr(e){return zt({contract:e.contract,method:[br,wr,pr],params:[e.hash,e.signature]})}const mr="0x6492649264926492649264926492649264926492649264926492649264926492";function Wt({address:e,data:n,signature:t}){return Ye([xt([{type:"address"},{type:"bytes"},{type:"bytes"}],[e,n,t]),mr])}const xr="0xfB688330379976DA81eB64Fe4BF50d7401763B9C";async function Ce({hash:e,signature:n,address:t,client:r,chain:o,accountFactory:i}){const s=(()=>{if(Je(n))return n;if(typeof n=="object"&&"r"in n&&"s"in n)return fr(n);if(n instanceof Uint8Array)return ur(n,"hex");throw new Error(`Invalid signature type for signature ${n}: ${typeof n}`)})(),c=await(async()=>!i||bn(s)?s:Wt({address:i.address,data:i.verificationCalldata,signature:s}))();let a;await tn(o)?a={to:xr,data:dn({abi:re,functionName:"isValidSig",args:[t,e,c]})}:a={data:hn({abi:re,args:[t,e,c],bytecode:ln})};const g=en({chain:o,client:r});try{const l=await $e(g,a);return nn(l)}catch{return!!await Xt({hash:e,signature:s,contract:pe({chain:o,address:t,client:r})}).catch(d=>(console.error("Error verifying EIP-1271 signature",d),!1))}}const Er="0x1626ba7e";async function Xt({hash:e,signature:n,contract:t}){try{return await yr({hash:e,signature:n,contract:t})===Er}catch{return!1}}const Br=`Ethereum Signed Message:
`;function vr(e,n){const t=typeof e=="string"?ee(e):e.raw instanceof Uint8Array?e.raw:rn(e.raw),r=ee(`${Br}${t.length}`);return tt(ye(r,t),n)}function Ar(e){const{domain:n={},message:t,primaryType:r}=e,o={EIP712Domain:an(n),...e.types};cn({domain:n,message:t,primaryType:r,types:o});const i=["0x1901"];if(n&&i.push(fn({domain:n,types:o})),r!=="EIP712Domain"){const s=(()=>{const c=ke({data:t,primaryType:r,types:o});return tt(c)})();i.push(s)}return tt(ye(...i.map(s=>on(s))))}function ke({data:e,primaryType:n,types:t}){const r=[{type:"bytes32"}],o=[Sr({primaryType:n,types:t})];if(!t[n])throw new Error("Invalid types");for(const i of t[n]){const[s,c]=ze({types:t,name:i.name,type:i.type,value:e[i.name]});r.push(s),o.push(c)}return xt(r,o)}function Sr({primaryType:e,types:n}){const t=me(Ir({primaryType:e,types:n}));return tt(t)}function Ir({primaryType:e,types:n}){let t="";const r=Me({primaryType:e,types:n});r.delete(e);const o=[e,...Array.from(r).sort()];for(const i of o){if(!n[i])throw new Error("Invalid types");t+=`${i}(${n[i].map(({name:s,type:c})=>`${c} ${s}`).join(",")})`}return t}function Me({primaryType:e,types:n},t=new Set){const r=e.match(/^\w*/u),o=r==null?void 0:r[0];if(t.has(o)||n[o]===void 0)return t;t.add(o);for(const i of n[o])Me({primaryType:i.type,types:n},t);return t}function ze({types:e,name:n,type:t,value:r}){if(e[t]!==void 0)return[{type:"bytes32"},tt(ke({data:r,primaryType:t,types:e}))];if(t==="bytes")return r=`0x${(r.length%2?"0":"")+r.slice(2)}`,[{type:"bytes32"},tt(r)];if(t==="string")return[{type:"bytes32"},tt(me(r))];if(t.lastIndexOf("]")===t.length-1){const o=t.slice(0,t.lastIndexOf("[")),i=r.map(s=>ze({name:n,type:o,types:e,value:s}));return[{type:"bytes32"},tt(xt(i.map(([s])=>s),i.map(([,s])=>s)))]}return[{type:t},r]}async function Cr({accountContract:e,factoryContract:n,options:t,message:r}){var a,u;const o=vr(r),i=await Re({factoryContract:n,accountContract:e,originalMsgHash:o});let s;if(i){const g=xt([{type:"bytes32"}],[o]);s=await t.personalAccount.signTypedData({domain:{name:"Account",version:"1",chainId:t.chain.id,verifyingContract:e.address},primaryType:"AccountMessage",types:{AccountMessage:[{name:"message",type:"bytes"}]},message:{message:g}})}else s=await t.personalAccount.signMessage({message:r});if(await xe(e)){if(await Xt({hash:o,signature:s,contract:e}))return s;throw new Error("Failed to verify signature")}else{const g=Ee({factoryContract:n,adminAddress:t.personalAccount.address,accountSalt:(a=t.overrides)==null?void 0:a.accountSalt,createAccountOverride:(u=t.overrides)==null?void 0:u.createAccount});if(!g)throw new Error("Create account override not provided");const l=await we(g),d=Wt({address:n.address,data:l,signature:s});if(await Ce({hash:o,signature:d,address:e.address,chain:e.chain,client:e.client}))return d;throw new Error("Unable to verify ERC-6492 signature after signing.")}}async function kr({accountContract:e,factoryContract:n,options:t,typedData:r}){var u,g,l,d,m;if(((g=(u=r.domain)==null?void 0:u.verifyingContract)==null?void 0:g.toLowerCase())===((l=e.address)==null?void 0:l.toLowerCase()))return t.personalAccount.signTypedData(r);const i=Ar(r),s=await Re({factoryContract:n,accountContract:e,originalMsgHash:i});let c;if(s){const A=xt([{type:"bytes32"}],[i]);c=await t.personalAccount.signTypedData({domain:{name:"Account",version:"1",chainId:t.chain.id,verifyingContract:e.address},primaryType:"AccountMessage",types:{AccountMessage:[{name:"message",type:"bytes"}]},message:{message:A}})}else c=await t.personalAccount.signTypedData(r);if(await xe(e)){if(await Xt({hash:i,signature:c,contract:e}))return c;throw new Error("Failed to verify signature")}else{const A=Ee({factoryContract:n,adminAddress:t.personalAccount.address,accountSalt:(d=t.overrides)==null?void 0:d.accountSalt,createAccountOverride:(m=t.overrides)==null?void 0:m.createAccount});if(!A)throw new Error("Create account override not provided");const y=await we(A),f=Wt({address:n.address,data:y,signature:c});if(await Ce({hash:i,signature:f,address:e.address,chain:e.chain,client:e.client}))return f;throw new Error("Unable to verify signature on smart account, please make sure the admin wallet has permissions and the signature is valid.")}}async function Re({factoryContract:e,accountContract:n,originalMsgHash:t}){try{const r=await zt({contract:e,method:"function accountImplementation() public view returns (address)"});return await zt({contract:pe({address:r,chain:n.chain,client:n.client}),method:"function getMessageHash(bytes32 _hash) public view returns (bytes32)",params:[t]}).then(i=>i!=="0x").catch(()=>!1)}catch{return!1}}export{Cr as smartAccountSignMessage,kr as smartAccountSignTypedData};
